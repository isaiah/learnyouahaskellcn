语法
========

### 模式匹配

本章将从模式匹配开始介绍Haskell的一些语法结构。模式匹配包括指定数据应该符合的模式和从匹配的数据中解析出对应模式的相应数据。

定义函数时，可以为不同的模式定义不同的函数体。这使代码更加整洁和易读。可以匹配任何模式－－数字，字符，列表，元组等等。我们先定义一个非常简单的函数来检查一个数字是是否等于7。

    lucky :: (Integral a) => a -> String  
    lucky 7 = "LUCKY NUMBER SEVEN!"  
    lucky x = "Sorry, you're out of luck, pal!"

当调用`lucky`时，将从上往下检查每一个模式，将有获得一个匹配的模式时，相应的函数体将被调用。这里只有数字7才能匹配到第一个模式，如果它不匹配，那将往下找到第二个模式，这个模式匹配任何数字并将它绑定到`x`。这个函数也可以用`if`语句实现。设想这样一个函数：对从1到5的参数打印相应的英文单词，对其他数字打印`"Not between 1 and 5"`，如果没有模式匹配，将需要一长串的`if..else..`。

    sayMe :: (Integral a) => a -> String  
    sayMe 1 = "One!"  
    sayMe 2 = "Two!"  
    sayMe 3 = "Three!"  
    sayMe 4 = "Four!"  
    sayMe 5 = "Five!"  
    sayMe x = "Not between 1 and 5"

注意如果把最后一个模式放到第一个，它将总是打印`"Not betwwen 1 and 5"`，因为这个模式将捕获所有参数以至于后面的模式从来不可能被检查到[^1]。

还记得前面实现的阶乘函数吗？我们将数字`n`的阶乘定义为`product [1..n]`。也可以用递归定义，就如阶乘在数学中的定义一样。首先将0的阶乘定为1，然后规定任何正整数的阶乘是这个整数与它上一个整数的阶乘的乘积。翻译成Haskell如下：

    factorial :: (Integral a) => a -> a  
    factorial 0 = 1  
    factorial n = n * factorial (n - 1)

这是我们第一次递归定义函数。递归在Haskell中非常重要，我们将在随后更深入了解。为了得到3的阶乘，Haskell将尝试计算`3 * factorial 2`，2的阶乘是`2 * factorial 1`，现在我们有了`3 * (2 * factorial 1)`。`factorial 1`等于`1 * factorial 0`，所以结果是`3 * (2 * (1 * factorial 0))`。技巧就在这里，我们在第一个模式将0的阶乘定义为1，所以最后的结果就是`3 * (2 * (1 * 1))`。如果我们把第二个模式放到前面，它将捕获包括0在内的所有数字，计算将永远无法终结。这就是为什么设置模式的时候顺序非常重要，越特殊的模式放在越前面而越一般的应该放在后面。

模式匹配也能失败。例如定义如下函数：

    charName :: Char -> String  
    charName 'a' = "Albert"  
    charName 'b' = "Broseph"  
    charName 'c' = "Cecil"

然后用非预期的参数调用，就会发生下面的情况：

    ghci> charName 'a'  
    "Albert"  
    ghci> charName 'b'  
    "Broseph"  
    ghci> charName 'h'  
    "*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName"

提示函数的模式不是穷尽的。当设置模式时，应该包含一个能捕获所有的模式这样程序就不会在碰到非预期的输入时崩溃。

模式匹配也能用于元组。假设需要一个函数将2D空间的两个向量（用二元组表示）进行相加。两个向量相加需要分别将每个向量的x部分和y部分相加，下面是不用模式匹配的写法：

    addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
    addVectors a b = (fst a + fst b, snd a + snd b)

这是正确的，但是可以用更好的方法实现。下面用模式匹配改造这个函数。

    addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
    addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

看起来好多了，并且这个是一个包含所有情况的模式。`addVectors`的类型是`addVectors :: (Num a) => (a, a) -> (a, a) - > (a, a)`，这样就能保证参数是两个二元组。

`fst`和`snd`能够分解二元组。但是三元组呢？系统没有预定义的函数，需要我们自己定义。

    first :: (a, b, c) -> a  
    first (x, _, _) = x  
      
    second :: (a, b, c) -> b  
    second (_, y, _) = y  
      
    third :: (a, b, c) -> c  
    third (_, _, z) = z

下划线`_`与它在列表集合中的含意相同。它意味着我们根本不关心那个部分是什么，所以只是一个`_`。

这让我想起在列表集合中也可以使用模式匹配，看看下面的集合：

    ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  
    ghci> [a+b | (a,b) <- xs]  
    [4,7,6,8,11,4]

如果一个模式匹配失败，它直接转移到下一个元素。

列表也能用于模式匹配。可以匹配空列表`[]`或者任何涉及`:`和空列表的模式。因为`[1,2,3]`只是`1:2:3:[]`的语法糖衣，也可以使用这个正式的模式。像`x:xs`这样的模式能将列表的头绑定到`x`，剩下的部分绑定到`xs`，即使这个列表只有一个元素，这样`xs`的值就是空列表。

> 注意： `x:xs`模式使用非常频繁，尤其在递归函数中。但是带有`:`的模式只能匹配到长度为1以上的列表。

如果想要绑定列表的头三个元素到变量，剩下的部分绑定到另一个变量，可以使用`x:y:z:zs`这样的模式。它只能匹配长度大于等于3的列表。

我们知道了怎么去匹配一个列表，现在来实现一个我们自己的`head`函数。

    head' :: [a] -> a  
    head' [] = error "Can't call head on an empty list, dummy!"  
    head' (x:_) = x

检查它能不能运行：

    ghci> head' [4,5,6]  
    4  
    ghci> head' "Hello"  
    'H'

注意如果想要绑定多个变量（即使其中一个只是`_`，并且实际上没有绑定什么东西），必须用括号括起来。同时注意到`error`函数，它接受一个字符串并生成一个运行时错误，用这个字符串表示发生的什么错误。它将导致程序崩溃，所以不要太多地使用它。但是对空列表使用`head`并没有什么意义。

现在让我们一个函数来用英语陈述一个列表的头几个元素。

    tell :: (Show a) => [a] -> String  
    tell [] = "The list is empty"  
    tell (x:[]) = "The list has one element: " ++ show x  
    tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y  
    tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
    
这个函数是安全的，因为它处理了空列表，单元素列表，两个元素的列表和超过两个元素的列表。`(x:[])`和`(x:y:[])`也可以写成`[x]`和`[x,y]`（因为它是语法糖衣，不需要括号）。但是不能将`x:y:_)`改写成方括号的形式，因为它匹配任何超过两元素的列表。

前面已经用列表集合实现过`length`，现在将使用模式匹配和递归实现它：

    length' :: (Num b) => [a] -> b  
    length' [] = 0  
    length' (_:xs) = 1 + length' xs

这与阶乘函数类似。首先定义一个特定输入（空列表）的结果，这通常也被称为边界条件。在第二个模式中将这个列表分割成头和尾两部分。总长度等于1加长尾巴的长度。我们用`_`来匹配头元素，因为我们实际上不关心这是什么东西。我们也照顾到了列表的所有情况，第一个模式匹配空列表，第二个模式能够匹配所有非空列表。





[^1]:这里类似于switch..case语句，但是其实模式匹配比switch语句要强大得多－－译者。
