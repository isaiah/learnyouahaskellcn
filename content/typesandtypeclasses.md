类型与Typeclass
============

### 相信类型

之前我们提到过Haskell有一个静态类型系统。每一个表达式的类型都可以在编译期确定，这样使代码更安全。如果你写一个用布尔值与数字相除的程序，这个程序将不能编译。这样的好处是可以在编译时就知道程序的错误而不用等到运行时崩溃才发现错误。Haskell的任何东西都有类型，这样编译期可以在编译前详细了解你的程序。

与Java或Pascal不同，Haskell有类型推断。如果我们写一个数字，不必告诉Haskell这是一个数字，它能自己推断出来，所以我们不必要显示写出所有函数和表达式的类型。我们将简单介绍一下Haskell的类型系统，但是理解这个系统是学习Haskell的一个重要部分。

类型是一个表达式的标签，标示一个表达式属于哪个种类。表达式True是布尔型，`"hello"`是字符串，等等。

现在用GHCI来检查一些表达式的类型。我们将使用`:t`命令，这个命令能告诉我们任何合法表达式的类型。

    ghci> :t 'a'  
    'a' :: Char  
    ghci> :t True  
    True :: Bool  
    ghci> :t "HELLO!"  
    "HELLO!" :: [Char]  
    ghci> :t (True, 'a')  
    (True, 'a') :: (Bool, Char)  
    ghci> :t 4 == 5  
    4 == 5 :: Bool

如上所示，对一个表达式使用`:t`将打印这个表达式和它的类型，中间用`::`分隔。`::`的表示“某某的类型是”。显式类型的第一个字母都是大写，如`a`的类型是`Char`，`True`的类型是`Bool`。但是检查`"HELLO!"`类型的结果是`[Char]`，这是什么？从方括号可以看出它是一个列表，所以我们可以把它看成是一个字符的列表。与此不同的是，每一个元组都有其独特的类型。因此`(True, 'a')`的类型是`(Bool, Char)`，而`('a','b','c')`的类型是`(Char,Char,Char)`。`4 == 5`总是返回`False`，所以它的类型是`Bool`。

函数也有类型，当定义我们自己的函数的时候，可以选择显式申明其类型。除了特别短的函数，这通常是一个比较好的实践。从此往后，我们将显式申明每一个新的函数的类型。前面见过的从一个字符串中过滤非大写字符的函数类型如下：

    removeNonUppercase :: [Char] -> [Char]  
    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

`removeNonUppercase`的类型是`[Char] -> [Char]`，意思是它将一个字符串映射为另一个字符串。类型`[Char]`是`String`的同义词，所以写成`removeNonUppercase :: String -> String`会更清晰一些。我们不必给这个函数申明类型，因为编译器能推断出来。如果一个函数有多个参数，它的类型是什么样的呢？下面是一个接受三个整数作为参数并返回其和的函数：

    addThree :: Int -> Int -> Int -> Int  
    addThree x y z = x + y + z

参数之间用`->`分隔，而且参数与返回值之间没有任何差别。返回值和参数的类型与其出现顺序相同。后面我们将看到为什么返回值的类型与参数和类型在函数类型申明有没有显式的差别。

如果想要申明函数的类型但是不确定该怎么写，可以先将这个函数写出来然后用`:t`检查其类型。函数也是表达式，因此`:t`也可以应用于其上。

下面将介绍一些常用的类型。

`Int`表示整数。它是绑定的，意味着有上下限，通常32位机的`Int`上限是2147483647，下限是-2147483648。

`Integer`也表示整数，区别是它是非绑定的，可以表示非常大的数。然而`Int`的性能要好很多。

    factorial :: Integer -> Integer  
    factorial n = product [1..n]

    ghci> factorial 50  
    30414093201713378043612608166064768844377641568960512000000000000

`Float`表示单精度浮点数。

    circumference :: Float -> Float  
    circumference r = 2 * pi * r  

    ghci> circumference 4.0  
    25.132742

`Double`是双精度浮点数。

    circumference' :: Double -> Double  
    circumference' r = 2 * pi * r  

    ghci> circumference' 4.0  
    25.132741228718345

`Bool`是布尔类型。只有`True`和`False`两个值。

`Char`表示字符类型，用单引号标示。

元组也是类型，依赖于它的长度和组成部分的类型，所以理论上有无穷多的元组类型。注意空元组`()`也是类型，它只有一个值`()`。

### 类型变量

`head`的类型是什么？它接受一个列表作为参数并返回列表的第一个元素，让我们检查一下：

    ghci> :t head  
    head :: [a] -> a

![a](http://s3.amazonaws.com/lyah/box.png)`a`是什么？它是一种类型吗？前面提到过所有类型的首字母都是大写，所以`a`不可能是一种类型。因为它不是大写的，所以它是一个**类型变量**。意味着`a`可以是任何类型。这更像其他语言里面的泛形，只是在Haskell里面更加强大，只要不使用某些类型的特殊行为，类型变量能让我们写出非常通用的函数。使用类型变量的函数称为**多态函数**。函数`head`的类型申明表示它可以接受由任何类型组成的列表并返回一个那种类型的元素。

虽然类型变量的名字可以比一个字母更长一些，我们通常用a,b,c,d...表示。

还记得`fst`吗？它返回二元组的头一个元素，让我们看看它的类型：

    ghci> :t fst  
    fst :: (a, b) -> a

`fst`接受一个由两种类型组成的元组并返回一个与元组第一个组件类型相同的元素。这就是为什么我们可以对任何类型的二元组使用`fst`。注意`a`和`b`是不同的类型变量，它们不必是不同的类型。它只是表示返回值的类型与第一个元素的类型是一样的。

### 类型类

类型类在某种意义上可以看作定义了一些行为的接口。如果一个类型属于一个类型类，表示这种类型实现了这种类型类定义的行为。许多来自OOP的人对类型类感到困惑，因为他们将其看作面向对象语言中的类。这是错误的观点，你可以将它看作是Java的接口，只是更强大一些。

`==`函数的类型是什么？

    ghci> :t (==)  
    (==) :: (Eq a) => a -> a -> Bool

注意：求等操作符`==`是一个函数，所以`+`，`*`，`-`，`/`等操作符都是函数。如果一个函数只由特殊字符组成，那么它默认是中缀函数。如果要检查它的类型，传递给另一个函数或者作为前缀函数调用，需要用括号包围。

上面出现了一个新的符号`=>`，`=>`符号前面的叫做**类约束**，我们可以将前面的类型申明翻译成：求等函数接受两个相同类型的值作为参数，并且返回一个`Bool`。这两个值的必须属于`Eq`类（这就是类约束）。

`Eq`类型类提供了检验相等性的接口。任何可以两个值的相等性的类型都应该是`Eq`类的成员。除IO（这个类处理输入输出）之外的所有Haskell的标准类型都是`Eq`的成员。

`elem`的类型是`(Eq a) => a -> [a] -> Bool`因为它使用`==`来检验某个值是否在一个列表中。

下面是一些基本的类型类：

`Eq`用于支持检验相等性的类型。其成员实现的函数是`==`和`/=`。因此如果一个函数的类约束包含`Eq`，那其定义一定使用了`==`或者`/=`。我们前面提到过的所有除函数之外的类型都是`Eq`的成员，它们都可以检验相等性。

    ghci> 5 == 5  
    True  
    ghci> 5 /= 5  
    False  
    ghci> 'a' == 'a'  
    True  
    ghci> "Ho Ho" == "Ho Ho"  
    True  
    ghci> 3.432 == 3.432  
    True

`Ord`用于可以排序的类型。

    ghci> :t (>)  
    (>) :: (Ord a) => a -> a -> Bool

前面提到过的所有除函数之外的类型都是`Ord`的成员，`Ord`涵盖了所有标准的比较函数如`>`，`<`，`>=`和`<=`。`compare`函数接受两个相同类型的值，他们的类型是`Ord`的成员，并返回一个`Ordering`值。`Ordering`有三个值`GT`，`LT`和`EQ`，相应的表示大于，小于和等于。

要实现`Ord`，必须先实现`Eq`类。

    ghci> "Abrakadabra" < "Zebra"  
    True  
    ghci> "Abrakadabra" `compare` "Zebra"  
    LT  
    ghci> 5 >= 2  
    True  
    ghci> 5 `compare` 3  
    GT

`Show`的成员可以用字符串表示。所有提到过的除函数之外的类型都是`Show`的成员。`Show`类型类的常用函数是`show`。它接受一个`Show`成员类型的值并将其用字符串展示。

    ghci> show 3  
    "3"  
    ghci> show 5.334  
    "5.334"  
    ghci> show True  
    "True"

`Read`可以看成是`Show`的反类型类。`read`函数接受一个字符串并返回一个`Read`成员类型的值。


    ghci> read "True" || False  
    True  
    ghci> read "8.2" + 3.8  
    12.0  
    ghci> read "5" - 2  
    3  
    ghci> read "[1,2,3,4]" ++ [3]  
    [1,2,3,4,3]

目前为止没有问题。但是如果只有`read "4"`会怎么样？

    ghci> read "4"  
    <interactive>:1:0:  
        Ambiguous type variable `a' in the constraint:  
          `Read a' arising from a use of `read' at <interactive>:1:0-7  
        Probable fix: add a type signature that fixes these type variable(s)

GHCI抛出的错误信息是它不知道应该返回什么类型。注意到前面使用`read`函数时对结果作了一些处理。在那种情况下，GHCI能推断出需要从`read`返回什么类型的值。如果将返回值当成布尔值使用，它就知道应该返回一个布尔值。但是现在它只知道需要返回一个属于`Read`类的类型，但是不知道具体应该是哪个类型。我们来看一看`read`函数的类型：

    ghci> :t read  
    read :: (Read a) => String -> a

这就是为什么我们可以显式**类型注解**。类型注解是一种显式标明表达式类型的方式，通过在表达式末尾加上`::`和相应的类型来指定表达式的类型。

    ghci> read "5" :: Int  
    5  
    ghci> read "5" :: Float  
    5.0  
    ghci> (read "5" :: Float) * 4  
    20.0  
    ghci> read "[1,2,3,4]" :: [Int]  
    [1,2,3,4]  
    ghci> read "(3, 'a')" :: (Int, Char)  
    (3, 'a')


