起步
=======

### 预备，跑！

好了，让我们正式开始吧！如果你跳过了前面的简介，最好看一下最后一个章节，因为它解释了跟随本教程的一些准备工作以及如果装载函数。我们要做的第一件事是运行ghc的交互环境并调用一些函数以获得关于haskell的一些基本认知。打开终端并输入ghci，你将看到这样一个欢迎界面：

        GHCi, version 7.0.2: http://www.haskell.org/ghc/  :? for help
        Loading package ghc-prim ... linking ... done.
        Loading package integer-gmp ... linking ... done.
        Loading package base ... linking ... done.
        Loading package ffi-1.0 ... linking ... done.
        Prelude> 

恭喜，现在你已经进入到GHCI！这里的提示是 Prelude>，当你向会话中装载其他东西时，这个提示会变长。我们将使用ghci>。如果你想要相同的提示，输入:set prompt "ghci> "。

首先来看一些简单的算术：

    ghci> 2 + 15  
    17  
    ghci> 49 * 100  
    4900  
    ghci> 1892 - 1472  
    420  
    ghci> 5 / 2  
    2.5  
    ghci>

以上基本是自解释的。我们可以在同一行使用几个操作符，通常的优先级次序会得到遵守。如果想使用负数，最好用括号括起来。5 * -3将出错，而5 * (-3)是正确的。

布尔代数是非常直观的。`&&`表示布尔和，`||`表示布尔或，`not`反转`True`或者`False`。

    ghci> True && False  
    False  
    ghci> True && True  
    True  
    ghci> False || True  
    True   
    ghci> not False  
    True  
    ghci> not (True && True)  
    False

测试相等可以这样：

    ghci> 5 == 5  
    True  
    ghci> 1 == 0  
    False  
    ghci> 5 /= 5  
    False  
    ghci> 5 /= 4  
    True  
    ghci> "hello" == "hello"  
    True

5 + "llama"或者5 == True会怎么样呢？如果输入第一个，将得到一条吓人的错误信息！

    No instance for (Num [Char])  
    arising from a use of `+' at <interactive>:1:0-9  
    Possible fix: add an instance declaration for (Num [Char])  
    In the expression: 5 + "llama"  
    In the definition of `it': it = 5 + "llama"

GHCI告诉我们 "llama"不是一个数字所以它不知道怎么将它和5相加。即使不是"llama"而是"four"或者"4"，Haskell仍然不知道怎样将其转换成数字。+号期望其左右都是数字。如果尝试执行True == 4，GHCI将告诉我们类型不匹配。+号只对数字有效而==则只可以运用于两个可以比较的东西。关键是有相同的类型。不能将苹果和桔子进行比较。随后将详细探讨类型。提示：可以进行5 + 4.0因为5既可以被看作整数也可以被看作浮点数。4.0不能看作整数，因此5需要进行转型。

虽然可能你没有注意到，我们从一开始就在使用函数。如 * 是将两个数相乘的函数。如上所示，通过将 * 操作符夹在两个操作数中间来调用它。这就是所谓的*中缀*函数。大多数不是用于数字的函数是*前缀*函数，下面来看看它们。

由于函数一般都是前缀的，所以往后将不会陈述某个函数是前缀的，而是默认的。大多数命令式语言通过将函数名和包括它的参数的括号放在一起来调用，这些参数通过逗号来分隔。在Haskell里面，函数名和参数之间用空格进行分隔。我们先看看一些无聊的函数：

    ghci> succ 8  
    9

succ函数接受任何有后继的东西作为参数并返回其后继。如上所示，函数名和它的参数之间只有空格进行分隔。调用有多个参数的函数同样很简单。max和min函数接受两个能进行排序的东西作为参数。min返回较小的那个max则相反。

    ghci> min 9 10  
    9  
    ghci> min 3.4 3.2  
    3.2  
    ghci> max 100 101  
    101

函数调用的优先级最高，因此以下两行代码的效果是一样的：

    ghci> succ 9 + max 5 4 + 1  
    16  
    ghci> (succ 9) + (max 5 4) + 1  
    16

然而，如果想要得到9乘10的下一个数，不能写成 succ 9 * 10，因为这样将得到9的下一个数，即10。与10相乘得到100。必须写成 succ (9 * 10) 以得到正确结果91。

如果一个函数有两个参数，也可以通过将这个函数包围在反引号中作为中缀函数来调用。例如，div接受两个整数作为参数并返回两个数的商。div 92 10的结果是9。但是如果这样调用可能会比较另人费解，因为分不清除数和被除数。因此可以通过 92 `div` 10 将它作为中缀函数来调用，这样就非常清晰。

许多来自命令式编程语言的人趋向于坚持括号是函数调用的象征。例如，C语言就是这样调用函数的foo()，bar(1)或者baz(3, "haha")。如前面所说，Haskell使用空格来表示函数调用。以上这些函数在Haskell就是foo，bar 1 和 baz 3 "haha"。所以如果看到bar (bar 3)，意思不是bar的参数是 bar 和 3，而是先通过参数3调用函数bar得到一个结果，再用这个结果调用bar。在C语言里这种情况表示为bar(bar(3))。

### Baby的第一个函数

在前一章，我们获得了函数调用的一些基本印象。现在来动手创建自己的函数。打开字符编辑器并敲入这个函数：

    doubleMe x = x + x

函数的定义方式与它们的调用方式类似。函数名与其参数通过空格分隔。不同的是在函数定义中有一个 = 并且其后是函数体。将这个文件保存为baby.hs，然后进入到保存这个文件的文件夹并运行ghci。进入到ghci后执行:l baby。这里脚本已经被载入，可以在ghci中调用刚刚定义的函数：

    ghci> :l baby  
    [1 of 1] Compiling Main             ( baby.hs, interpreted )  
    Ok, modules loaded: Main.  
    ghci> doubleMe 9  
    18  
    ghci> doubleMe 8.3  
    16.6

因为 + 可以运用于整数和浮点数（实际上是任何可以被当作是数的东西），这个函数可以运用于任何数字。现在我们来定义一个函数，接受两个数字作为参数，将两者都乘以2再将结果相加。

    doubleUs x y = x*2 + y*2

简单。也可以定义成 doubleUs x y = x + x + y + y。记得将这个函数加到baby.hs的末尾，保存然后在ghci执行:l baby。

    ghci> doubleUs 4 9  
    26  
    ghci> doubleUs 2.3 34.2  
    73.0  
    ghci> doubleUs 28 88 + doubleMe 123  
    478

如你所料，可以在新的函数的定义中调用其他函数，这样可以将doubleUs重新定义为：

{:.haskell}
        doubleUs x y = doubleMe x + doubleMe y

这是Haskell常见的模式，创建一些明显正确的函数然后再将这些函数组合成更为复杂的函数。这样能避免重复。

Haskell对函数的定义顺序没有要求，所以是先定义doubleMe再定义doubleUs或者反过来都无关紧要。

接下来创建一个函数，当其参数小于或等于100时返回其与2的乘积，否则返回本身！

{:.haskell}
        doubleSmallNumber x = if x > 100  
                        then x  
                        else x * 2

![IMG](http://s3.amazonaws.com/lyah/baby.png)

这里引入了Haskell的 if 声明。Haskell的 if 的命令式语言的 if 的差别在于Haskell对else部分是强制的。在命令式语言中如果条件不满足可以跳过一些特定的步骤，但是在Haskell中每一个表达式和函数都必须具有返回值。也可以把整个if声明写在一行，不过这种方式比较可读。Haskell的if声明的另一个特点是它是一个*表达式*，表达式基本上就是具有返回值的段代码。5是一个表达式因为它的返回值是5，4 + 8是表达式，x + y 也是表达式因为返回x和y的和。因为else部分是强制的，所以if声明一定会有返回值。如果要给以上的函数返回值再增加1，可以将函数体写成这样：

{:.haskell}
    doubleSmallNumber' x = (if x > 100 then x else x*2) + 1

如果省略括号，就只会在x大于100时加1。注意函数名后面的'。单引号在Haskell的语法中没有任何特殊意义，是函数名的合法字符。一般使用'来表示一个函数的严格版本（非惰性），或者一个函数或者变量的稍微变化的版本。因为'是函数名的合法字符，可以声明一个这样的函数：

    conanO'Brien = "It's a-me, Conan O'Brien!"

这里有两件事值得注意。第一Conan的首字母没有大字，那是因为函数名不能以大写字母开头，随后将解释这么做的原因。另一个特点是这个函数没有不接受任何参数。当一个函数不接受任何参数时，通常说这是一个*定义*（或者*名字*）。因为一旦定义之后我们不能改变名字（和函数）的含义， `conanO'Brien`和字符串`"It's a-me, Conan O'Brien!"`能没有差别地使用。

### 列表List

![Lists](http://s3.amazonaws.com/lyah/list.png)

正如真实世界的购物列表，列表在Haskell中也是非常有用的。这是最常使用的数据结构，可以通过很多不同的方法解决很多不同的问题。列表非常强大。本节将介绍关于列表，字符串（也是列表）和列表集合的基本知识。

在Haskell中，列表是同质的数据结构。它存储的是多个同一类型的元素。这意味着可以有整数列表或者字符列表，但是不存在一半是整数一半是字符的列表。

注意：在GHCI中用 let 关键字定义一个常量(name)。`let a = 1`等同于在脚本中写`a = 1`然后装载到GHCI。

    ghci> let lostNumbers = [4,8,15,16,23,42]  
    ghci> lostNumbers  
    [4,8,15,16,23,42]

如上所示，列表通过方括号表示，其中的元素用逗号分隔。如果尝试定义像`[1,2,'a',3,'b','c',4]`这样的列表，Haskell就会抱怨字符（通过单引号标示）不是数字。说到字符，字符串就是字符的列表。`"hello"`只是`['h','e','l','l','o']`的简写。因为字符串是列表，所以可以对其应用列表的函数，非常方便。

常见的任务是联结两个列表，这是通过`++`运算符来完成的。

    ghci> [1,2,3,4] ++ [9,10,11,12]  
    [1,2,3,4,9,10,11,12]  
    ghci> "hello" ++ " " ++ "world"  
    "hello world"  
    ghci> ['w','o'] ++ ['o','t']  
    "woot"

当对长字符串使用`++`运算符时应当注意，把一个单例列表（只有一个元素的列表）追加到另一个列表后面时，在Haskell内部需要遍历`++`左边的整个列表。如果这个列表不是很长这还不是问题。但如果把什么东西追回到一个有5千万元素的列表后面就要花一些时间。然而，把一个元素加到另一个列表前面的操作符`:`（也称作联结符）就几乎不需要什么时间。

    ghci> 'A':" SMALL CAT"  
    "A SMALL CAT"  
    ghci> 5:[1,2,3,4,5]  
    [5,1,2,3,4,5]

注意`:`的参数是一个数字和一个数字列表或者一个字符和一个字符列表，而`++`操作的参数是两个列表。即使只是往一个列表后面追回一个元素也需要用方括号把这个元素包围起来以使之成为一个列表。

`[1,2,3]`实际上只是`1:2:3:[]`的简化形式。`[]`是一个字列表。如果把3加到它前面，就成为了`[3]`。加把2加到前面就是`[2,3]`，等等。

注意：`[]`，`[[]]`和`[[],[],[]]`是不同的东西。

如果要通过索引获取列表的某一个元素，使用`!!`操作符，索引由0算起。

        ghci> "Steve Buscemi" !! 6  
        'B'  
        ghci> [9.4,33.2,96.2,11.2,23.25] !! 1  
        33.2

如果尝试去获取一个只有4个元素的列表的第60个元素，将抛出一个错误。

列表的元素本身也可以是列表。

        ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
        ghci> b  
        [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
        ghci> b ++ [[1,1,1,1]]  
        [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]  
        ghci> [6,6,6]:b  
        [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
        ghci> b !! 2  
        [1,2,2,3,4]

列表的子表可以不同长度，但是必须是相同类型。如同不会有半字符半数字的列表，也不存在一些子表是字符的列表，另一些子表是数字的列表。

如果组成列表的元素可以进行比较，那么列表之间也可以进行比较。当使用`<`，`<=`，`>`和`>=`进行比较时，通过元素出现的先后顺序进行比较。首先比较第一个元素，然后是第二个元素，依次类推。

    ghci> [3,2,1] > [2,1,0]  
    True  
    ghci> [3,2,1] > [2,10,100]  
    True  
    ghci> [3,4,2] > [3,4]  
    True  
    ghci> [3,4,2] > [2,4]  
    True  
    ghci> [3,4,2] == [3,4,2]  
    True

对列表可以执行哪些操作呢？下面是操作列表的一些基本函数。

`head`返回一个列表的头，列表的头通常是它的第一个元素。

        ghci> head [5,4,3,2,1]  
        5

`tail`返回一个列表的尾。换句话说，去掉了列表的头。

    ghci> tail [5,4,3,2,1]  
    [4,3,2,1]

`last`返回列表的最后一个元素。

    ghci> last [5,4,3,2,1]  
    1

`init`返回除最后一个元素之外的其余部分。

    ghci> init [5,4,3,2,1]  
    [5,4,3,2]

如果把列表看成是一个怪兽，这就是以上每个部分的含义。

![monster](http://s3.amazonaws.com/lyah/listmonster.png)

如果去获取一个空列表的头会发现什么情况呢？

    ghci> head []  
    *** Exception: Prelude.head: empty list

天哪，它就在我们面前爆炸了！如果没有怪兽也就没有头。注意不要对空列表使用`head`，`tail`，`last`和`init`。这种错误不能在编译期捕获，所有要警惕不小心让Haskell返回一个空列表的任何东西。

`length`反正一个列表的长度。

    ghci> length [5,4,3,2,1]  
    5

`null`检查一个列表是否为空。请使用这个函数而不是`xs == []`（假设有一个叫xs的列表）

    ghci> null [1,2,3]  
    False  
    ghci> null []  
    True

`reverse`反转一个列表。

    ghci> reverse [5,4,3,2,1]  
    [1,2,3,4,5]

`take`接受一个数字n和一个列表，返回从第一个元素算起的n个元素。

    ghci> take 3 [5,4,3,2,1]  
    [5,4,3]  
    ghci> take 1 [3,9,3]  
    [3]  
    ghci> take 5 [1,2]  
    [1,2]  
    ghci> take 0 [6,6,6]  
    []

当列表的长度小于要求的个数时，返回整个列表。如果取得0个元素就得到一个空列表。

`drop`和前者差不多，不同的是丢弃从第一个元素算起的n个元素。

        ghci> drop 3 [8,4,2,1,5,6]  
        [1,5,6]  
        ghci> drop 0 [1,2,3,4]  
        [1,2,3,4]  
        ghci> drop 100 [1,2,3,4]  
        []

`maximum`接受一个由可以进行排序的元素构成的列表并返回其中的最大值。

`minimum`返回最小值。

        ghci> minimum [8,4,2,1,5,6]  
        1  
        ghci> maximum [1,9,2,3,4]  
        9

`sum`接受一个数字组成的列表，并返回它们的总和。

`product`返回一个数字列表的元素的乘积。

    ghci> sum [5,2,1,6,3,2,5,7]  
    31  
    ghci> product [6,2,1,2]  
    24  
    ghci> product [1,2,5,6,7,9,2,0]  
    0

`elem`接受一个东西和一个列表并返回这个东西是否是列表的一个元素。通常用中缀的方式调用，因为这种更好读。

    ghci> 4 `elem` [3,4,5,6]  
    True  
    ghci> 10 `elem` [3,4,5,6]  
    False

以上只是列表操作的一部分，[随后](/modules#data-list)将介绍更多的函数。

### 范围

当需要一个1到20的数字列表该怎么办？当然，可以把这个列表的数字都敲出来，但是显然对一个要求卓越的程序员来说这样太山寨了。他们都用区间。区间（Range）是构建由可枚举的元素组成的等差数列的一种方式。数字可以枚举，字母也可以枚举，字母表可以看作是从A到Z的一个枚举。名字不可以枚举，“JOHN”后面是谁？我不知道。

`[1..20]`表示从1到20的自然数的列表，这和`[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`是等价的，除了后者看起来稍微有点蠢。

        ghci> [1..20]  
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
        ghci> ['a'..'z']  
        "abcdefghijklmnopqrstuvwxyz"  
        ghci> ['K'..'Z']  
        "KLMNOPQRSTUVWXYZ"

区间另一个更酷的特点是可以设定增幅。如1到20的偶数，或者1到20的每第三个数。

    ghci> [2,4..20]  
    [2,4,6,8,10,12,14,16,18,20]  
    ghci> [3,6..20]  
    [3,6,9,12,15,18]

只需要把头两个元素用逗号分隔，然后给出上限。虽然区间相当智能，但还没有智能到许多人预期的程序。不能写`[1,2,4,8,16..100]`然后希望得到一个自然数的2次方的数列。首先因为只能给定固定的增幅，其次如果只给出开头的几个元素许多非数字的序列是可以有多种解释的。

从20到1的数列，不是`[20..1]`，而是`[20,19..1]`。

在区间使用浮点数时应该注意，因为浮点数不是完全精确的（根据定义），在区间使用可能会产生奇怪的结果。

    ghci> [0.1, 0.3 .. 1]  
    [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]

建议不要在区间使用浮点数。

也可以通过不设置区间的上限来获取一个无穷列表。随后会了解更多关于无穷列表的情况。现在先看看怎样得到从1到24与13的乘积的数列，当然可以写`[13,26..24*13]`，但是`take 24 [13,26..]`看起来更好。因为Haskell是惰性的，它不会马上对无穷列表求值。直到收到需要前24数字的指令，它才对表达式求值。

有许多函数构建无穷列表：

`cycle`把一个列表循环成一个无穷列表。如果要展现结果，它将无限进行下去，因此需要在某个地方将其截断。

    ghci> take 10 (cycle [1,2,3])  
    [1,2,3,1,2,3,1,2,3,1]  
    ghci> take 12 (cycle "LOL ")  
    "LOL LOL LOL "

`repeat`接受一个元素作为参数并产生只包含此元素的无穷列表，和热循环一个只有一个元素的列表相同。

    ghci> take 10 (repeat 5)  
    [5,5,5,5,5,5,5,5,5,5]

如果只是想要一定数量的单一元素列表，使用`replicate`函数会更简单一些。

### List集合

如果曾经学习过数学课程，那一定接触过set集合。它们的用处是用一般的set集合构建更专门的set集合。一个包含头10个偶自然数的set集合是![set annotation](http://s3.amazonaws.com/lyah/setnotation.png)。管道（竖线）前面的部分称为输出函数，`x`是变量，`N`是输入`x <= 10`是约束。该集合包含满足约束的所有自然数的双倍。

用Haskell表示是`take 10 [2,4..]`。但如果需要的不是头10个自然数的双倍，而是一些应用过其上的更复杂的函数？我们可以使用list集合。List集合和set集合非常类似。上面的集合可以表示为list集合`[x*2 | x <- [1..10]]`。`x`从`[1..10]`提取，对`[1..10]`中的每一个元素（绑定到`x`），求其双倍。下面是这个集合：

        ghci> [x*2 | x <- [1..10]]  
        [2,4,6,8,10,12,14,16,18,20]

下面给这个集合增加一个约束（或条件），约束出现在绑定部分后面，用逗号分隔。假设只需要乘以2后大于等于12的元素。

    ghci> [x*2 | x <- [1..10], x*2 >= 12]  
    [12,14,16,18,20]

对了。那么50到100之间除以7余3的所有数呢？

    ghci> [ x | x <- [50..100], x `mod` 7 == 3]  
    [52,59,66,73,80,87,94]

成功了！通过约束把一些元素从集合中除去也称为**过滤**。来看看另一个例子，假如需要这样一个集合，把所有大于10的奇数替换为`"BANG!"`，其他小于10的奇数替换为`"BOOM!"`。如果不是奇数就从这个集合中扔掉。我们把这个集合放入一个函数以便于重用。

    boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]

集合的最后一部分是约束。如果一个数是奇数，`odd`函数返回`True`，否则返回`False`。只有当约束返回`True`时这个元素才会被包含在集合中。

    ghci> boomBangs [7..13]  
    ["BOOM!","BOOM!","BANG!","BANG!"]

可以包含多个约束，例如所有10到20之间不等于13，15或者19的数字：

    ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]  
    [10,11,12,14,16,17,18,20]

List集合中不但可以包含多个约束（包含在结果列表中的元素必须满足约束），也可以从多个列表中提取。当从多个列表中提取时，产生对所有列表元素的组合应用输出函数的合并集合。如果不进行过滤，由两个长度为4的列表产生的集合的长度是16。假如有`2,5,10]`和`[8,10,11]`两个集合，可以通过下面的集合得到所有由两个集合的元素乘积的组合。

    ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]  
    [16,20,22,40,50,55,80,100,110]

和预料中一样，新的列表的长度是9。如果需要所有结果中大于50的元素呢？

    ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]  
    [55,80,100,110]

由形容词的列表和一个名词列表的元素的组合成的史诗：

    ghci> let nouns = ["hobo","frog","pope"]  
    ghci> let adjectives = ["lazy","grouchy","scheming"]  
    ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]  
    ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",  
    "grouchy pope","scheming hobo","scheming frog","scheming pope"]

我明白了，让我写一个自己的`length`!把它叫做`length'`。

    length' xs = sum [1 | _ <- xs]

`_`表示不关心从列表中提取的东西，与其申明一个从来不可能用到的变量，不如直接写一个`_`。这个函数把列表中的所有元素替换成1然后求其总和。这意味着结果就是这个列表的长度。

提示：因为字符串也是列表，我们可以使用list集合去处理字符串。下面的函数把删掉字符串中的所有非大写字母的字符。

    removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

试试效果：

    ghci> removeNonUppercase "Hahaha! Ahahaha!"  
    "HA"  
    ghci> removeNonUppercase "IdontLIKEFROGS"  
    "ILIKEFROGS"

约束做了所有工作，它过滤了所有没包含在`['A'..'Z']`中的元素。如果操作的是包含列表的列表，那么嵌套list集合也是可能的。下面在不平铺列表的情况下从一个由数列组成的列表中移除奇数元素：

    ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]  
    ghci> [ [ x | x <- xs, even x ] | xs <- xxs]  
    [[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]

可以将一个list拆分成多行，所以如果不是在GHCI中，最好将一个长的list集合拆分成多行，尤其当有嵌套的时候。

### 元组
